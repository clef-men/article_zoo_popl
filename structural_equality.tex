\section{Structural equality}
\label{sec:structural_equality}

Structural equality~\refTheories{zoo/program_logic/structural_equality.v} is also supported.
More precisely, it is not part of the semantics of the language but implemented using low-level primitives%
\footnote{
In \OCaml, these primitives correspond to the unsafe functions \ocamlinline{Obj.is_int}, \ocamlinline{Obj.tag}, \ocamlinline{Obj.size} and \ocamlinline{Obj.field}.
}.
The reason is that it is in fact difficult to specify for arbitrary values.
In general, we have to compare graphs --- which implies structural comparison may diverge.

Accordingly, the specification of $v_1\ \texttt{=}\ v_2$ requires the (partial) ownership of a \emph{memory footprint} corresponding to the union of the two compared graphs, giving the permission to traverse them safely.
If it terminates, the comparison decides whether the two graphs are bisimilar (modulo representation conflicts, as described in \cref{sec:physical_equality}).
In \Iris, this gives:
\[
  \iSpec{
    \textlog{val-traversable}\ \mathit{footprint}\ v_1 \iSep \\
    \textlog{val-traversable}\ \mathit{footprint}\ v_2 \iSep \\
    \textlog{structeq-footprint}\ \mathit{footprint}
  }{
    v_1\ \texttt{=}\ v_2
  }{
    b
  }{
    \myifOneline{
      b
    }{
      \textlog{val-structeq}\ \mathit{footprint}\ v_1\ v_2
    }{
      \textlog{val-structneq}\ \mathit{footprint}\ v_1\ v_2
    }
  }
\]

Obviously, this general specification is not very convenient to work with.
Fortunately, for abstract values (without any mutable part), we can prove a much simpler variant saying that structural equality coincides with physical equality in absence of generative or mutable constructors:
\[
  \iSpec{
    \textlog{val-abstract}\ v_1 \iSep \\
    \textlog{val-abstract}\ v_2
  }{
    v_1\ \texttt{=}\ v_2
  }{
    b
  }{
    \myifOneline{
      b
    }{
      v_1 \similar v_2
    }{
      v_1 \nonsimilar v_2
    }
  }
\]

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End:
