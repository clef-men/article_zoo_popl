\section{Related Work}
\label{sec:related}

We have amply covered related work on verification of concurrent fine-grained data structures in  the paper. We focus here on program verification and the question of physical equality.

\subsection{Non-automated Verification}

The verified program is translated, manually or in an automated way, into a representation living inside a proof assistant.
The user has to write specifications and prove them.

Translating into the native language of the proof assistant, such as Gallina for \Rocq, is challenging as it is hard to faithfully preserve the semantics of the source language, which typically has non-terminating functions for example. Monadic translations should support it, but faithfully encoding all impure behaviors is challenging, and tools typically provide a best-effort translation~\citep*{coq-of-ocaml,DBLP:conf/cpp/Spector-Zabusky18} that is only approximately sound.

The representation may be embedded, meaning the semantics of the language is formalized in the proof assistant.
This is the path taken by some recent works (for example \citet*{DBLP:journals/pacmpl/GondelmanHPTB23}) harnessing the power of separation logic.
In particular, the following works target \OCaml:

% (1) \CFML~\citep*{DBLP:books/hal/Chargueraud23}, (2) \Osiris~\citep*{SeassauYMP25} and (3) \DRFCaml~\citep*{DBLP:journals/pacmpl/GeorgesPEWDECPD25} target \OCaml.

(1) \CFML~\citep*{DBLP:books/hal/Chargueraud23} does not support concurrency and is not based on \Iris.

(2) \Osiris~\citep*{SeassauYMP25} is based on \Iris and covers algebraic data types, exceptions and effect handlers following \citet*{DBLP:journals/pacmpl/VilhenaP21}.
However, it does not support concurrency and its perfectionist rather than pragmatic treatment of undetermined evaluation order makes it harder to use than \HeapLang or \Zoo for program verification; it may not yet be ready for practical verification at scale --- certainly not for our problem domain.

(3) \DRFCaml~\citep*{DBLP:journals/pacmpl/GeorgesPEWDECPD25} is based on \Iris and does support concurrency.
It is mostly an extension of \HeapLang with features (modalities and stack regions) entirely orthogonal to our work.
It distinguishes atomic and non-atomic locations, with a sequential memory model for atomics and undefined behavior for non-atomic races.
This implies that programs whose safety can be verified in the program logic are data-race free, and thus their strongly sequential semantics is compatible with  \OCamlFive thanks to the DRF property~\citep*[Theorem 14]{DBLP:conf/pldi/DolanSM18}.
In other words, \DRFCaml has a sequentially consistent memory model but its program logic rejects programs that would allow extra (defined) behaviors in the \OCamlFive memory model.
Many concurrent programs that we want to verify do contain non-atomic races for performance reasons (or could use relaxed atomics if those were available), so they cannot be verified directly in \DRFCaml.
In contrast, we prove their functional correctness in our sequentially consistent model.

%Prior to our work, \HeapLang was thus the most appropriate tool to verify concurrent \OCaml programs.
%We discussed limitations of \HeapLang in the introduction and \ZooLang is our proposal to improve on this.
%Conversely, one notable limitation of \ZooLang today is its lack of support for \OCaml's relaxed memory model.

\subsection{Semi-automated Verification}

In semi-automated verification approaches, the verified program is annotated by the user to guide the verification tool: preconditions, postconditions, invariants, \etc.
Given this input, the verification tool generates proof obligations that are mostly automatically discharged.
One may further distinguish two types of semi-automated systems: \emph{foundational} and \emph{non-foundational}.

In \emph{non-foundational} automated verification, the tool and external solvers it may rely on are part of the trusted computing base.
It is the most common approach and has been widely applied in the literature~\citep*{DBLP:journals/jfp/SwamyCFSBY13, DBLP:series/natosec/0001SS17, DBLP:conf/nfm/JacobsSPVPP11, DBLP:conf/icfem/DenisJM22, DBLP:conf/nfm/AstrauskasBFGMM22, DBLP:conf/esop/FilliatreP13, DBLP:journals/pacmpl/LattuadaHCBSZHPH23, DBLP:journals/pacmpl/PulteMSMSK23}, including to \OCaml by \Cameleer~\citep*{DBLP:conf/cav/PereiraR20}, which uses the \Gospel specification language~\citep*{DBLP:conf/fm/ChargueraudFLP19} and \WhyThree~\citep*{DBLP:conf/esop/FilliatreP13}.

In \emph{foundational} automated verification, proofs are checked by a proof assistant so the automation does not have to be trusted.
To our knowledge, it has been applied to \C~\citep*{DBLP:conf/pldi/SammlerLKMD021} and \Rust~\citep*{DBLP:journals/pacmpl/GaherSJKD24}.

\Zoo is mostly non-automated --- except for our use \Diaframe for local automation of separation logic reasoning. We would be interested in moving towards more automation in the future.

\subsection{Physical Equality}
\label{subsec:related-work-physical-equality}

There is some literature in proof-assistant research on reflecting physical equality from the implementation language into the proof assistant, for optimization purposes: for example, exposing \OCaml's physical equality as a predicate in \Rocq lets us implement some memoization and sharing techniques in \Rocq libraries.
%
However, axiomatizing physical equality in the proof assistant is difficult and can result in inconsistencies.

The earlier discussions of this question that we know come from Jourdan's thesis~\citep*[chapter 9]{DBLP:phd/hal/Jourdan16}, presented more succintly in \citep*{DBLP:journals/jar/BraibantJM14}.
%
This work introduces the Jourdan condition, that physical equality implies equality of values.
%
\citep*{boulme:tel-03356701} extends the treatment of physical equality in \Rocq, integrating it in an ``extraction monad'' to control it safely.
%
A similar approach for \Lean is discussed in \citep*{DBLP:journals/pacmpl/SelsamHM20}.

The correctness of the axiomatization of physical equality depends on the type of the values being compared: axiomatizations are typically polymorphic on any type \coqinline{A}, but their correctness depends on the specific \coqinline{A} being considered.
%
For example, it is easy to correctly characterize physical equality on natural numbers, and other non-dependent types arising in \Rocq verification projects.
%
One difficulty in \HeapLang and \ZooLang is that they are untyped languages, their representation of \ocamlinline{0} and \ocamlinline{false} has the same type.
%
But our remark that structural equality (in \OCaml) does not necessarily coincide with definitional equality (in \Rocq) also applies to other \Rocq types: our examples with an existential \ocamlinline{Any} constructor (see~\cref{sec:physical_equality}) can be reproduced with $\Sigma$-types.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End:
