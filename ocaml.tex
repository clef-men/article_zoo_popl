\section{\OCaml extensions for fine-grained concurrent programming}
\label{sec:ocaml}

Over the course of this work, we studied efficient fine-grained concurrent \OCaml programs written by experts.
This revealed various limitations of \OCaml in these domains, that those experts would work around using unsafe casts, often at the cost of both readability and memory-safety; and also some mismatches between their mental model of the semantics of \OCaml and the mental model used by the \OCaml compiler authors.
We worked on improving \OCaml itself to reduce these work-arounds or semantic mismatches.

\subsection{Atomic record fields}
\label{sec:atomic-record-fields}

\OCamlFive offers a type \ocamlinline{'a Atomic.t} of atomic references exposing sequentially consistent atomic operations.
Data races on non-atomic mutable locations has a much weaker semantics and is generally considered a programming error.
For example, the Michael-Scott concurrent queue~\citep*{DBLP:conf/podc/MichaelS96} relies on a linked list structure that could be defined as follows:
\begin{ocamlcode}
type 'a node = Nil | Cons of { value : 'a; next : 'a node Atomic.t }
\end{ocamlcode}

Performance-minded concurrency experts dislike this representation, because \ocamlinline{'a Atomic.t} introduces an indirection in memory: it is represented as a pointer to a block containing the value of type \ocamlinline{'a}. We have found unsafe tricks such as unsafely casting a record into an atomic value, to operate atomically on its first field.

In May-June 2024 we proposed a design for atomic record fields as an \OCaml language change proposal%
\footnote{
\url{https://github.com/ocaml/RFCs/pull/39}
}%
.
Declaring a record field atomic simply requires an \ocamlinline{[@atomic]} attribute --- and could eventually become a proper keyword of the language.
\begin{ocamlcode}
(* re-implementation of atomic references *)
type 'a atomic_ref = { mutable contents : 'a [@atomic]; }

(* concurrent linked list *)
type 'a node = Nil | Cons of { value: 'a; mutable next : 'a node [@atomic]; }

(* bounded SPSC circular buffer *)
type 'a bag = { data : 'a Atomic.t array;
                mutable front: int [@atomic];
                mutable back: int [@atomic]; }
\end{ocamlcode}

The design difficulty is to express atomic operations on atomic record fields.
For example, if \ocamlinline{buf} has type \ocamlinline{'a bag} above, then one naturally expects the existing notation \ocamlinline{buf.front} to perform an atomic read and \ocamlinline{buf.front <- n} to perform an atomic write.
But how would one express exchange, compare-and-set and fetch-and-add?
We would like to avoid adding a new primitive language construct for each atomic operation.

Our final design, first proposed by Basile ClÃ©ment%
    \footnote{
    \url{https://github.com/ocaml/RFCs/pull/39\#issuecomment-2147862938}
    }%
    , introduces a built-in type \ocamlinline{'a Atomic.Loc.t} for an atomic location that holds an element of type \ocamlinline{'a}, with a syntax extension \ocamlinline{[%atomic.loc e.f]} to construct such locations.
    Atomic primitives operate on values of type \ocamlinline{'a Atomic.Loc.t} and they are exposed as functions of the module \ocamlinline{Atomic.Loc}.
    For example, the standard library exposes:
\begin{ocamlcode}
val Atomic.Loc.fetch_and_add : int Atomic.Loc.t -> int -> int
\end{ocamlcode}
    and users can write:
\begin{ocamlcode}
let preincrement_front (buf : 'a bag) : int =
  Atomic.Loc.fetch_and_add [%atomic.loc buf.front] 1
\end{ocamlcode}
    where \ocamlinline{[%atomic.loc buf.front]} has type \ocamlinline{int Atomic.Loc.t}.

    Internally, a value of type \ocamlinline{'a Atomic.Loc.t} can be represented as a pair of a record and an integer offset for the desired field, and the \ocamlinline{atomic.loc} construction builds this pair in a well-typed manner.
    When a primitive of the \ocamlinline{Atomic.Loc} module is applied to an \ocamlinline{atomic.loc} expression, the compiler can optimize away the construction of the pair --- but it would happen if there was an abstraction barrier between the construction and its use.

In August and September 2024 we implemented this design proposal, and submitted it for inclusion in the \OCaml compiler%
\footnote{
\url{https://github.com/ocaml/ocaml/pull/13404}
}%
.
We got a full code review by Olivier Nicole%
\footnote{
\url{https://github.com/ocaml/ocaml/pull/13404\#pullrequestreview-2291958008}
}%
. It took much longer for a consensus to form among \OCaml maintainers on the feature, due to the question of whether an alternative design would be preferable, that would have
%
\ocamlinline{[%atomic.field front]}
%
at type \ocamlinline{('a bag, int) Atomic.Field.t}. Between November 2024 and January 2025 we also implemented this alternative design and found type-checking issues\footnote{See \url{https://github.com/ocaml/ocaml/pull/13707}}, which finally lead to a maintainer consensus on the \ocamlinline{Atomic.Loc} proposal, which was merged in May 2025, and first released in \OCaml 5.4.

\paragraph{Limitation: no support for cache contention}
The type \ocamlinline{Atomic.t} comes with a function
\begin{ocamlcode}
val Atomic.make_contended : 'a -> 'a Atomic.t
\end{ocamlcode}
that ensures that the returned atomic reference is allocated with enough alignment and padding to sit alone on its cache line, to avoid performance issues caused by false sharing.
Currently there is no such support for padding of atomic record fields (we are planning to work on this), so the less-compact atomic references remain preferable in certain scenarios.

\subsection{Atomic arrays}
\label{subsec:atomic-arrays}

% On top of our atomic record fields, we have implemented experimental support for atomic arrays, another facility commonly requested by authors of efficient concurrent programs.
Our previous example of a concurrent bag of type \ocamlinline{'a bag} used a backing array of type \ocamlinline{'a Atomic.t array}, which contains more indirections than may be desirable, as each array element is a pointer to a block containing the value of type \ocamlinline{'a}, instead of storing the value of type \ocamlinline{'a} directly in the array.

We have an experimental implementation of atomic arrays%
\footnote{
\url{https://github.com/clef-men/ocaml/tree/atomic_array}
}
% builds on top of the type \ocamlinline{'a Atomic.Loc.t} we described in the previous section
% , and it relies on two new low-level primitives provided by the compiler:
% \begin{ocamlcode}
% val Atomic_array.index : 'a array -> int -> 'a Atomic.Loc.t
% val Atomic_array.unsafe_index : 'a array -> int -> 'a Atomic.Loc.t
% \end{ocamlcode}
%
% The function \ocamlinline{index} takes an array and an integer index within the array, and returns an atomic location into the corresponding element after performing a bound check.
% \ocamlinline{unsafe_index} omits the boundcheck --- additional performance at the cost of memory-safety --- and allows to express the atomic counterpart of the unsafe operations \ocamlinline{Array.unsafe_get} and \ocamlinline{Array.unsafe_set}.
% The atomic primitives of the module \ocamlinline{Atomic.Loc} can then be used on these indices
% ; our implementation
on top of the \ocamlinline{Atomic.Loc} primitives, which provides direct array operations such as:
\begin{ocamlcode}
val Atomic.Array.exchange        : 'a Atomic.Array.t -> int -> 'a -> 'a
val Atomic.Array.unsafe_exchange : 'a Atomic.Array.t -> int -> 'a -> 'a
\end{ocamlcode}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End:
