\section{\Zoo features}
\label{sec:features}

In this section, we review the salient features of \Zoo, which we found lacking when we attempted to use \HeapLang to verify real-world \OCaml programs.
We start with the most generic ones and then address those related to concurrency.

\subsection{Algebraic data types}

\Zoo is an untyped language but, to write interesting programs, it is convenient to work with abstractions like algebraic data types.
To simulate tuples, variants and records, we designed a machinery to define projections, constructors and record fields.

For example, one may define a list-like type with:

\begin{coqcode}
Notation "'Nil'"  := (in_type "t" 0) (in custom zoo_tag).
Notation "'Cons'" := (in_type "t" 1) (in custom zoo_tag).
\end{coqcode}

Users do not need to write this incantation directly, as they are generated by \texttt{ocaml2zoo} from the \OCaml type declarations.
Suffice it to say that it introduces the two tags in the \texttt{zoo\_tag} custom entry, on which the notations for data constructors rely.
The \coqinline{in_type} term is needed to distinguish the tags of distinct data types; crucially, it cannot be simplified away by \Rocq, as this could lead to confusion during the reduction of expressions.

Given this incantation, one may directly use the tags \texttt{Nil} and \texttt{Cons} in data constructors using the corresponding \ZooLang constructs:

\begin{coqcode}
Definition map : val :=
  rec: "map" "fn" "t" =>
    match: "t" with
    | Nil => §Nil
    | Cons "x" "t" =>
        let: "y" := "fn" "x" in
        ‘Cons( "y", "map" "fn" "t" )
    end.
\end{coqcode}

Similarly, one may define a record-like type with two mutable fields \texttt{f1} and \texttt{f2}:

\begin{coqcode}
Notation "'f1'" := (in_type "t" 0) (in custom zoo_field).
Notation "'f2'" := (in_type "t" 1) (in custom zoo_field).

Definition swap : val :=
  fun: "t" =>
    let: "f1" := "t".{f1} in
    "t" <-{f1} "t".{f2} ;; "t" <-{f2} "f1".
\end{coqcode}

\subsection{Mutually recursive functions}

\Zoo supports non-recursive ($\texttt{fun:}\ x_1 \dots x_n\ \texttt{=>}\ e$) and recursive ($\texttt{rec:}\ f\ x_1 \dots x_n\ \texttt{=>}\ e$) functions but only \emph{toplevel} mutually recursive functions.
It is non-trivial to properly handle mutual recursion: when applying a mutually recursive function, a naive approach would replace calls to sibling functions by their respective bodies, but this typically makes the resulting expression unreadable.
To prevent it, the mutually recursive functions have to know one another to preserve their names during $\beta$-reduction.
We simulate this using some boilerplate that can be generated by \texttt{ocaml2zoo}.
For instance, one may define two mutually recursive functions \texttt{f} and \texttt{g} as follows:

\begin{coqcode}
Definition f_g := (
  recs: "f" "x" => "g" "x"
  and:  "g" "x" => "f" "x"
)%zoo_recs.

(* boilerplate *)
Definition f := ValRecs 0 f_g.
Definition g := ValRecs 1 f_g.
Instance : AsValRecs' f 0 f_g [f;g]. Proof. done. Qed.
Instance : AsValRecs' g 1 f_g [f;g]. Proof. done. Qed.
\end{coqcode}

\subsection{Standard library}

To save users from reinventing the wheel, we provide a standard library---more or less a subset of the \OCaml standard library.
Currently, it mainly includes standard data structures like: array (\ocamlinline{Array}), resizable array (\ocamlinline{Dynarray}), list (\ocamlinline{List}), stack (\ocamlinline{Stack}), queue (\ocamlinline{Queue}), double-ended queue, mutex (\ocamlinline{Mutex}), condition variable (\ocamlinline{Condition}).

Each of these standard modules contains \ZooLang functions and their verified specifications.
These specifications are modular: they can be used to verify more complex data structures.
As an evidence of this, lists~\citeAnonymous{DBLP:journals/pacmpl/AllainC0S24} and arrays~\citeAnonymous{allain:hal-04681703} have been successfully used in verification efforts based on \Zoo.

\subsection{Concurrent primitives}
\label{sec:atomic}

\Zoo supports concurrent primitives both on atomic references (from \ocamlinline{Atomic}) and atomic record fields (from \ocamlinline{Atomic.Loc}\footnote{The \ocamlinline{Atomic.Loc} module is part of the \href{https://github.com/ocaml/ocaml/pull/13404}{PR} that implements atomic record fields (see \cref{sec:ocaml}).}) according to the table below.
The \OCaml expressions listed in the left-hand column translate into the \Zoo expressions in the right-hand column.
Notice that an atomic location \ocamlinline[escapeinside=||]{[%atomic.loc |$e$|.|$f$|]} (of type \ocamlinline{_ Atomic.Loc.t}) translates directly into $e \texttt{.[} f \texttt{]}$.

\begin{center}
\begin{tabular}{ll}
    \OCaml &
    \Zoo
  \\ \hline
    \ocamlinline[escapeinside=||]{Atomic.get |$e$|} &
    $\texttt{!} e$
  \\
    \ocamlinline[escapeinside=||]{Atomic.set |$e_1$| |$e_2$|} &
    $e_1\ \texttt{<-}\ e_2$
  \\
    \ocamlinline[escapeinside=||]{Atomic.exchange |$e_1$| |$e_2$|} &
    $\texttt{Xchg}\ e_1 \texttt{.[contents]}\ e_2$
  \\
    \ocamlinline[escapeinside=||]{Atomic.compare_and_set |$e_1$| |$e_2$| |$e_3$|} &
    $\texttt{CAS}\ e_1 \texttt{.[contents]}\ e_2\ e_3$
  \\
    \ocamlinline[escapeinside=||]{Atomic.fetch_and_add |$e_1$| |$e_2$|} &
    $\texttt{FAA}\ e_1 \texttt{.[contents]}\ e_2$
  \\
    \ocamlinline[escapeinside=||]{Atomic.Loc.exchange [%atomic.loc |$e_1$|.|$f$|] |$e_2$|} &
    $\texttt{Xchg}\ e_1 \texttt{.[} f \texttt{]}\ e_2$
  \\
    \ocamlinline[escapeinside=||]{Atomic.Loc.compare_and_set [%atomic.loc |$e_1$|.|$f$|] |$e_2$| |$e_3$|} &
    $\texttt{CAS}\ e_1 \texttt{.[} f \texttt{]}\ e_2\ e_3$
  \\
    \ocamlinline[escapeinside=||]{Atomic.Loc.fetch_and_add [%atomic.loc |$e_1$|.|$f$|] |$e_2$|} &
    $\texttt{FAA}\ e_1 \texttt{.[} f \texttt{]}\ e_2$
\end{tabular}
\end{center}

One important aspect of this translation is that atomic accesses (\ocamlinline{Atomic.get} and \ocamlinline{Atomic.set}) correspond to plain loads and stores.
This is because we are working in a sequentially consistent memory model: there is no difference between atomic and non-atomic memory locations.

\subsection{Prophecy variables}
\label{sec:prophecy}

Lock-free algorithms exhibit complex behaviors.
To tackle them, \Iris provides powerful mechanisms such as \emph{prophecy variables}~\cite{DBLP:journals/pacmpl/JungLPRTDJ20}.
Essentially, prophecy variables can be used to predict the future of the program execution and reason about it.
They are key to handle \emph{future-dependent linearization points}: linearization points that may or may not occur at a given location in the code depending on a future observation.

\Zoo supports prophecy variables through the \texttt{Proph} and \texttt{Resolve} expressions---as in \HeapLang, the canonical \Iris language.
In \OCaml, these expressions correspond to \ocamlinline{Zoo.proph} and \ocamlinline{Zoo.resolve}, that are recognized by \texttt{ocaml2zoo}.
